% LTeX: enabled=true

%% ADD ALL MISSING REFERENCES

As mentioned in the introduction, the current project works as an interaction
of three different fields: 1. counting complexity and combinatorial interpretation, 
2. total search problems and PPAD and 3. Kleene logic.


\subsection{Counting Complexity and Combinatorial Interpretations}
As we previously mentioned, we say that an object or a structure $f$
has a combinatorial interpretation if $f \in \textbf{\#P}$. $\textbf{\#P}$
is a complexity class created by Valiant \cite{valiantComplexityComputingPermanent1979},
to define a formal combinatorial framework in complexity theory.


\begin{definition}[$\textbf{\#P}$ Complexity Class]
    $\textbf{\#P}$ is a class of functions $f: \{0,1\}^* \to \mathbb{N}$
    such that: there exists a polynomial time non-deterministic
    Turing machine $N: \{0,1\}^* \to \{0,1\}$ such that
    $$
    \forall w \in \{0,1\}^*: f(w) = \textit{\#acc}_N(w)
    $$
    Where $\textit{\#acc}_N(\cdot)$, denotes the number of accepting paths.
    Equivalently, we may also use the definition of: There
    exists a polynomial deterministic TM $M$, and
    $p : \mathbb{N} \to \mathbb{N}$ such that $p \in n^{O(1)}$, we have:
    $$
    f(w) = \Big|\Big\{v \in \{0,1\}^{p(|w|)} \mid M(w, v) =1 \Big\}\Big|
    $$
\end{definition}

$\textbf{\#P}$ was initially created by \cite{valiantComplexityComputingPermanent1979},
to demonstrate, that even if we have a problem $L \in P$, $\#L$ can be computationally
hard to compute, by providing an example of computing the permanent of
a 01-matrix, with number of perfect matchings. 

As we can see, $\textbf{\#P}$ allows us to define a set of objects,
whose cardinality equals $f(w)$. Core reasoning for choosing
$\textbf{\#P}$ to define combinatorial objects is mainly for the 
following two reasons \cite{ikenmeyerPositivitySymmetricGroup2024}: 

\begin{enumerate}
    \item By polynomially bounding words, we avoid cases such as: $f(w) = \{1, \hdots, f(w)\}$
    \item Current framework allows us to work with $f(\cdot)$, whose direct computation can be computationally hard
\end{enumerate}


The current framework was used in several papers such as
\cite{ikenmeyerWhatWhatNot2022} and \cite{ikenmeyerPositivitySymmetricGroup2024}
where they were able to use tools from complexity theory to show that
many structures do or do not have a combinatorial interpretation.
For the purposes of the current project, we are focusing on \cite{ikenmeyerWhatWhatNot2022},
where they demonstrated how several $\textsc{TFNP}$ problems, 
change in complexity as we ignore one of its solutions.

\subsection{Total Search Problems and PPAD}
When talking about search problems, we are using the following definition:

\begin{definition}[Search Problems and Total Search Problems]
    \textbf{Search problems} can be defined as relations $R \subseteq \{0,1\}^* \times \{0,1\}^*$,
    where given $x \in \{0,1\}^*$, we want to find $y \in \{0,1\}^*$  such that $x Ry$.

    \textbf{Total Search problems} are search problems such that:
    $$
    \forall x \in \{0,1\}^*, \exists y \in \{0,1\}^* : xRy
    $$
\end{definition}

Using the above, we can define the following complexity clasess

\begin{definition}[FP, FNP, TFNP]
    \textbf{FP} are \textit{search problems} such that there exists poly-time TM $M$
    such that $M(x) = y$ where $x Ry$.

    \textbf{FNP} are \textit{search problems} such that there exists poly-time TM $M: \{0,1\}^* \to \{0,1\}$
    and a poly function $p : \mathbb{N} \to \mathbb{N}$ such that:
    $$
    \forall x \in \{0,1\}^*, y \in \{0,1\}^{p(|x|)}: xRy \iff M(x,y) = 1
    $$
    Lastly $\textbf{TFNP} = \{L \in \textbf{TFNP} \mid L \text{ is total}\}$
\end{definition}

Our current work focuses on a specific subclass of $\textbf{TFNP}$ problems
which is defined as follows:

\begin{definition}[\textit{EndOfLine} problem]
    Given circuits $S, P \in \{0,1\}^n \to \{0,1\}^n$ such that $S,P \in n^{O(1)}$
    we define a directed graph $G = (V,E)$, such that $V= \{0,1\}^n$ and $E$ defined as:
    $$
    E = \{(x,y) \in V^2: S(x) = y \wedge P(y) = x\}
    $$
    We define are source or sinks $\forall v \in V: \textit{deg}(v) = (0,1)$ or
    $\textit{deg}(v) = (1,0)$, respectively. We want to output
    $v$ that is either a source or a sink.
\end{definition}


\begin{definition}[Levin Reductions]
    Given a pair of search problems $R_A, R_B$, a pair of
    computable time functions $(f,g)$ is called a Levin reduction from $R_A \to R_B$
    \begin{gather*}
        S_R \triangleq \{x \mid \exists y : xRy  \}\\
        R(x) \triangleq \{y \mid x Ry \} \\
        \forall x \in S_{R_A}, y_b \in R(f(x)):  (x , g(x, y_b)) \in R_A
    \end{gather*}
\end{definition}

\begin{definition}[\textbf{PPAD} complexity class]
    \textbf{PPAD} is defined as the set of search problems that
    are levin reducible to the \textsc{EndOfLine} problem
\end{definition}


\textbf{PPAD} has been created by Papadimitriou \cite{papadimitriouComplexityParityArgument1994}
to demonstrate a subset of problems in \textbf{NP} that are guaranteed to have
a solution but can be very difficult to find. We will define
several problems of interest as they will be referenced in later sections.

\begin{definition}[\textit{SourceOrExcess} problem]
    We define as $\textit{SourceOrExcess}(k,1)$ for $k \in \mathbb{N}_{\geq 2}$
    the search problem as such: Given a poly-sized successor circuit $S : \{0,1\}^n$
    and a set of predecssor poly-sized circuits $\{P_i\}_{i \in [k]}$, we define
    the graph $G = (V,E)$ such that, $V = \{0,1\}^n$ and $E$ as:
    $$
    \forall x, y \in V^2: (x,y) \in E \iff (S(x) = y) \wedge \bigvee_{i \in [k]} P_i(y) = x
    $$
    We ensure that $0^n$ is as sink, meaning $\text{deg}(0^n) = (0,1)$.
    A valid solution is a vertex $v$ such that $\textit{in-deg}(v) \neq \textit{out-deg}(v)$
\end{definition}




\begin{definition}[\textit{Sperner} problem]
    %Add
\end{definition}







These problems have found
connections with various other problems such as Nash Equilbria,
Fixed point theorems or Sperner Lemmas. The current project looks
on the counting complexity of such problems as despite two problems
being PPAD-complete, Ikenmeyer et al. has showed several examples where
their counting difficulty can differ vastly. Examples of such statements
can be summarised as:

\begin{gather*}
    \textbf{\#PPAD}(\textsc{SourceOrSink})-1/2  = \textbf{\#P}\\
    \textbf{\#PPAD}(\textsc{SourceOrExcess})-1/2  = \textbf{\#P}\\
\end{gather*} 


\subsection{Kleene Logic and Hazard-Free Circuits}


